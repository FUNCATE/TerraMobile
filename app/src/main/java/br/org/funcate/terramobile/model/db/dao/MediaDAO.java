package br.org.funcate.terramobile.model.db.dao;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

import br.org.funcate.terramobile.R;
import br.org.funcate.terramobile.model.db.DBField;
import br.org.funcate.terramobile.model.db.DatabaseHelper;
import br.org.funcate.terramobile.model.exception.DAOException;
import br.org.funcate.terramobile.model.exception.InvalidAppConfigException;
import br.org.funcate.terramobile.util.ResourceHelper;

/**
 * Created by Andre Carvalho on 20/11/15.
 */
public class MediaDAO {
    private DatabaseHelper database;

    public MediaDAO(DatabaseHelper database) throws InvalidAppConfigException, DAOException {
        if(database!=null)
        {
            this.database = database;
        }
        else
        {
            throw new DAOException(ResourceHelper.getStringResource(R.string.invalid_database_exception));
        }
    }

    /**
     * Get list of the medias and your respective binary data.
     * @param mediaTable, the name of the media table
     * @param featureID, id of the associated feature.
     * @return A HashMap that contains the key and binary data to the pictures.
     * @throws Exception
     */
    public Map<String,Object> getMedias (String mediaTable, long featureID) throws Exception, DAOException {

        Collection<DBField> tabFields = getFieldsForMediaTable(mediaTable);
        String where = buildWhereClauseFeatureId(tabFields, featureID);

        Iterator<DBField> itField = tabFields.iterator();
        String fieldNameBLOB="";
        String primaryKey="";
        while (itField.hasNext()) {
            DBField field = itField.next();
            if(field.getFieldType().toLowerCase().equals("blob")) {// picture column
                fieldNameBLOB = field.getFieldName();
            }else if(field.isPrimaryKey()) {
                primaryKey = field.getFieldName();
            }
        }

        Cursor c = this.database.getReadableDatabase().query(mediaTable, new String[]{primaryKey, fieldNameBLOB}, where, null, null, null, null);
        Map<String,Object> media = new HashMap<String, Object>();

        try {
            if (c.moveToFirst()) {
                do {
                    int index = c.getColumnIndex(primaryKey);
                    String key = String.valueOf(c.getInt(index));
                    index = c.getColumnIndex(fieldNameBLOB);
                    media.put(key, c.getBlob(index));
                } while (c.moveToNext());
            }
        }catch (Exception e) {
            /**
             * It is know that one error occur when one image's size is larger than 2MB.
             * ... "only support a string or BLOB length up to 2147483647" ...
             * See this page about "Limits In SQLite": https://www.sqlite.org/limits.html
             * To more info about this, read the benchmark this page: http://www.sqlite.org/intern-v-extern-blob.html
             */
            e.printStackTrace();
            c.close();
            throw new Exception(e.getMessage());
        }
        c.close();
        return media;
    }
    /**
     * To Insert the media files on media table into a GeoPackage. Media table is not default on Geopackage.
     * @param mediaTable, the name of the media table
     * @param featureID, The identity of the Feature to associate media and Feature.
     * @param medias, the media's bytes into an Array of medias
     * @return, A list of the media identifiers generated by database on insert process.
     * @throws Exception
     */
    public long[] insertMedias (String mediaTable, long featureID, ArrayList<Object> medias) throws Exception, DAOException {
        Collection<DBField> tabFields = getFieldsForMediaTable(mediaTable);

        ArrayList<ContentValues> allValues=buildInsertValues(medias, tabFields, featureID);

        long[] insertedMediaID = new long[medias.size()];
        int c = 0;

        Iterator<ContentValues> it = allValues.iterator();
        while (it.hasNext()) {
            ContentValues contentValues = it.next();
            insertedMediaID[c] = this.database.getWritableDatabase().insert(mediaTable, null, contentValues);
            c++;
        }

        return insertedMediaID;
    }

    /**
     * Method for get Fields of the Media Table
     * @param mediaTable, name of the media table
     * @return Fields for media table
     */
    private Collection<DBField> getFieldsForMediaTable(String mediaTable) throws DAOException {

        if (mediaTable.isEmpty()) {
            throw new DAOException("Undefined table name.");
        }
        String sqlTableDescription = "PRAGMA table_info( "+mediaTable+" )";
        SQLiteDatabase db = this.database.getReadableDatabase();
        Cursor dbCursor = db.rawQuery(sqlTableDescription, null);

        String[] columnNames = dbCursor.getColumnNames();
        int countColumns = columnNames.length;
        int countRows = dbCursor.getCount();
        Collection<DBField> tabFields = new HashSet<DBField>(countRows);
        if (dbCursor.moveToFirst()) {
            do {

                DBField dbField = new DBField();

                for (int c = 0; c < countColumns; c++) {

                    String columnName = columnNames[c];
                    int columnIndex = dbCursor.getColumnIndex(columnName);

                    if ("name".equalsIgnoreCase(columnName)) {
                        dbField.setFieldName(dbCursor.getString(columnIndex));
                    } else if ("type".equalsIgnoreCase(columnName)) {
                        dbField.setFieldType(dbCursor.getString(columnIndex));
                    } else if ("pk".equalsIgnoreCase(columnName)) {
                        int pk = dbCursor.getInt(columnIndex);
                        dbField.setPrimaryKey(pk==1);
                    }
                }

                tabFields.add(dbField);
            } while (dbCursor.moveToNext());
        }

        return tabFields;
    }

    /**
     * Remove all medias associated to one feature, except the keep medias in imageKeep list.
     * @param mediaTable
     * @param imagesKeep, ids of the kept medias
     * @param featureID, id of the associated feature.
     * @return int, the number of the affected rows
     * @throws Exception
     */
    public int removeMedias (String mediaTable, ArrayList<String> imagesKeep, long featureID) throws Exception, DAOException {

        Collection<DBField> tabFields = getFieldsForMediaTable(mediaTable);
        String where = buildWhereClauseMediaIds(imagesKeep, tabFields);
        String[] whereArgs = new String[1];
        whereArgs[0] = ""+featureID;
        return this.database.getWritableDatabase().delete(mediaTable, where, whereArgs);
    }

    /**
     * Create a list of the ContentValues instances with pairs of the names and values for inserting into a media table.
     *
     * @param medias, the list of the medias in binary format.
     * @param tabFields The GeoPackage table fields to use for building the map.
     * @param featureID, the identified of the associated feature
     * @return The list of ContentValues with key and value pairs.
     * @throws IOException
     */
    private ArrayList<ContentValues> buildInsertValues(ArrayList<Object> medias, Collection<DBField> tabFields, long featureID) throws IOException {

        // Construct values
        int len = medias.size();
        ArrayList<ContentValues> arrayListContentValues = new ArrayList<ContentValues>(len);
        Iterator<Object> itMedia = medias.iterator();

        while (itMedia.hasNext()) {
            ContentValues contentValues = new ContentValues(tabFields.size());
            Object anObject = itMedia.next();
            byte[] pictureData = new byte[0];
            if(anObject!=null) pictureData = (byte[])anObject;

            if(pictureData!=null) {
                // For each field defined in the table...
                for (DBField f : tabFields) {

                    if (f.isPrimaryKey())
                        continue; // We can't insert or update the PK! shall be autoincrement

                    // if integer is feature_id column
                    if (f.getFieldType().toLowerCase().equals("integer")) {
                        contentValues.put(f.getFieldName(), featureID);
                    } else if (f.getFieldType().toLowerCase().equals("blob")) {
                        contentValues.put(f.getFieldName(), pictureData);
                    } else if (f.getFieldType().toLowerCase().equals("text")) {
                        contentValues.put(f.getFieldName(), "image/jpeg");
                    }
                }

                arrayListContentValues.add(contentValues);
            }
        }

        return arrayListContentValues;
    }

    /**
     * Create a WHERE Clause to remove medias that in are mediaIds
     *
     * @param mediaIds, the list of the media ids.
     * @param tabFields The GeoPackage table fields to use for building the map.
     * @return The where clause to remove query.
     * @throws IOException
     */
    private String buildWhereClauseMediaIds(ArrayList<String> mediaIds, Collection<DBField> tabFields) throws Exception {

        String where = "";
        String ids = "";
        String fieldFeatureId = "";
        String fieldPrimaryKey = "";
        for (DBField f : tabFields) {
            if (f.isPrimaryKey()) {
                fieldPrimaryKey = f.getFieldName();
            }else if ("integer".equalsIgnoreCase(f.getFieldType())) {
                fieldFeatureId = f.getFieldName();
            }
        }
        if(fieldPrimaryKey.isEmpty() || fieldFeatureId.isEmpty()) {
            throw new Exception("Unknown media table.");
        }

        if(mediaIds!=null && !mediaIds.isEmpty()) {

            Iterator<String> itIds = mediaIds.iterator();

            while (itIds.hasNext()) {

                String id = itIds.next();
                if (id != null && !id.isEmpty())
                    ids += (ids.isEmpty() ? "" : ",") + id;
            }
        }

        if(!ids.isEmpty()) where = fieldPrimaryKey + " NOT IN (" + ids + ") AND "+fieldFeatureId+"=?";
        else where = fieldFeatureId+"=?";

        return where;
    }

    /**
     * Create a WHERE Clause with the feature id
     *
     * @param tabFields The GeoPackage table fields to use for building the map.
     * @return The where clause with feature_id column.
     * @throws Exception
     */
    private String buildWhereClauseFeatureId(Collection<DBField> tabFields, long featureID) throws Exception {

        String where;
        String fieldFeatureId = "";
        for (DBField f : tabFields) {
            if (!f.isPrimaryKey() && f.getFieldType().toLowerCase().equals("integer")) {// feature_id column from media table
                fieldFeatureId = f.getFieldName();
                break;
            }
        }
        if(fieldFeatureId.isEmpty()) {
            throw new Exception("The Field Feature Id, not found on media table.");
        }

        where = fieldFeatureId + "=" + featureID;

        return where;
    }

    public boolean dropTable(String mediaTable) throws InvalidAppConfigException, DAOException {
        SQLiteDatabase db=null;
        try {
            db = database.getWritableDatabase();
            if (db != null) {
                db.beginTransaction();
                String sql = "DROP TABLE "+mediaTable;
                db.execSQL(sql);
                db.setTransactionSuccessful();
            }
        } catch (SQLiteException e) {
            e.printStackTrace();

            if(db!=null) db.close();

            throw new DAOException(ResourceHelper.getStringResource(R.string.media_table_delete_exception),e);
        }
        if(db!=null) {
            db.endTransaction();
            db.close();
            return true;
        }
        return false;
    }
}

package br.org.funcate.terramobile.model.db.dao;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;

import br.org.funcate.terramobile.R;
import br.org.funcate.terramobile.model.db.DBField;
import br.org.funcate.terramobile.model.db.DatabaseHelper;
import br.org.funcate.terramobile.model.exception.DAOException;
import br.org.funcate.terramobile.model.exception.InvalidAppConfigException;
import br.org.funcate.terramobile.model.service.MediaService;
import br.org.funcate.terramobile.util.ResourceHelper;

/**
 * Created by Andre Carvalho on 20/11/15.
 */
public class MediaDAO {
    private DatabaseHelper database;

    public MediaDAO(DatabaseHelper database) throws InvalidAppConfigException, DAOException {
        if(database!=null)
        {
            this.database = database;
        }
        else
        {
            throw new DAOException(ResourceHelper.getStringResource(R.string.invalid_database_exception));
        }
    }

    /**
     * Get list of the medias and your respective binary data.
     * @param mediaTable, the name of the media table
     * @param featureID, id of the associated feature.
     * @return A HashMap that contains the key and binary data to the pictures. The binary data are divide in thumbnail binary data and binary data in display size.
     * The structure contents: mediaIdentify=>{binaryData:{thumbnailBinary, displayBinary}}
     * @throws Exception
     */
    public Map<String,Object> getMedias (String mediaTable, long featureID) throws Exception, DAOException, InvalidAppConfigException {

        Collection<DBField> tabFields = getFieldsForMediaTable(mediaTable);
        String where = buildWhereClauseFeatureId(tabFields, featureID);

        String columnThumbnail = ResourceHelper.getStringResource(R.string.picture_thumbnail_media);
        String columnDisplayPhoto = ResourceHelper.getStringResource(R.string.picture_medium_size_media);

        Iterator<DBField> itField = tabFields.iterator();
        String fieldNameDisplayBLOB="";
        String fieldNameThumbnailBLOB="";
        String primaryKey="";
        while (itField.hasNext()) {
            DBField field = itField.next();
            if(field.getFieldType().equalsIgnoreCase("blob")) {// picture column

                if (field.getFieldName().equalsIgnoreCase(columnThumbnail)) {
                    fieldNameThumbnailBLOB = field.getFieldName();
                }else if (field.getFieldName().equalsIgnoreCase(columnDisplayPhoto)) {
                    fieldNameDisplayBLOB = field.getFieldName();
                }

            }else if(field.isPrimaryKey()) {
                primaryKey = field.getFieldName();
            }
        }

        if(fieldNameThumbnailBLOB.isEmpty() || fieldNameDisplayBLOB.isEmpty()) {
            throw new DAOException("Missing attribute column on media table.");
        }

        Cursor c = this.database.getReadableDatabase().query(mediaTable, new String[]{primaryKey, fieldNameThumbnailBLOB, fieldNameDisplayBLOB}, where, null, null, null, null);
        Map<String, Object> media = new HashMap<String, Object>();

        try {
            if (c.moveToFirst()) {
                do {
                    int index = c.getColumnIndex(primaryKey);
                    byte[][] blobs = new byte[2][];
                    String key = String.valueOf(c.getInt(index));
                    index = c.getColumnIndex(fieldNameThumbnailBLOB);
                    blobs[0] = c.getBlob(index);
                    index = c.getColumnIndex(fieldNameDisplayBLOB);
                    blobs[1] = c.getBlob(index);
                    media.put(key, blobs);
                } while (c.moveToNext());
            }
        }catch (Exception e) {
            /**
             * It is know that one error occur when one image's size is larger than 2MB.
             * ... "only support a string or BLOB length up to 2147483647" ...
             * See this page about "Limits In SQLite": https://www.sqlite.org/limits.html
             * To more info about this, read the benchmark this page: http://www.sqlite.org/intern-v-extern-blob.html
             */
            e.printStackTrace();
            c.close();
            throw new Exception(e.getMessage());
        }
        c.close();
        return media;
    }
    /**
     * To Insert the media files on media table into a GeoPackage. Media table is not default on Geopackage.
     * @param mediaTable, the name of the media table
     * @param featureID, The identity of the Feature to associate media and Feature.
     * @param medias, the media's bytes into an Array of medias
     * @return A list of the media identifiers generated by database on insert process.
     * @throws Exception
     */
    public long[] insertMedias (String mediaTable, long featureID, ArrayList<String> medias, Map<String, Integer> mediaDimensions) throws Exception, DAOException, InvalidAppConfigException {
        Collection<DBField> tabFields = getFieldsForMediaTable(mediaTable);

        ArrayList<ContentValues> allValues=buildInsertValues(medias, tabFields, featureID, mediaDimensions);

        long[] insertedMediaID = new long[medias.size()];
        int c = 0;

        SQLiteDatabase db=null;
        try {
            db = database.getWritableDatabase();
            if (db != null) {
                db.beginTransaction();

                for (ContentValues contentValues : allValues) {
                    insertedMediaID[c] = db.insert(mediaTable, null, contentValues);
                    c++;
                }

                db.setTransactionSuccessful();
            }
        } catch (SQLiteException e) {
            e.printStackTrace();

            if(db!=null) db.close();

            throw new DAOException(ResourceHelper.getStringResource(R.string.media_table_insert_exception),e);
        }
        if(db!=null) {
            db.endTransaction();
            db.close();
        }

        return insertedMediaID;
    }

    /**
     * Method for get Fields of the Media Table
     * @param mediaTable, name of the media table
     * @return Fields for media table
     */
    private Collection<DBField> getFieldsForMediaTable(String mediaTable) throws DAOException {

        if (mediaTable.isEmpty()) {
            throw new DAOException("Undefined table name.");
        }
        String sqlTableDescription = "PRAGMA table_info( "+mediaTable+" )";
        SQLiteDatabase db = this.database.getReadableDatabase();
        Cursor dbCursor = db.rawQuery(sqlTableDescription, null);

        String[] columnNames = dbCursor.getColumnNames();
        int countRows = dbCursor.getCount();
        Collection<DBField> tabFields = new HashSet<DBField>(countRows);
        if (dbCursor.moveToFirst()) {
            do {

                DBField dbField = new DBField();

                for (String columnName : columnNames) {

                    int columnIndex = dbCursor.getColumnIndex(columnName);

                    if ("name".equalsIgnoreCase(columnName)) {
                        dbField.setFieldName(dbCursor.getString(columnIndex));
                    } else if ("type".equalsIgnoreCase(columnName)) {
                        dbField.setFieldType(dbCursor.getString(columnIndex));
                    } else if ("pk".equalsIgnoreCase(columnName)) {
                        int pk = dbCursor.getInt(columnIndex);
                        dbField.setPrimaryKey(pk == 1);
                    }
                }

                tabFields.add(dbField);
            } while (dbCursor.moveToNext());
        }

        dbCursor.close();

        return tabFields;
    }

    /**
     * Remove all medias associated to one feature, except the keep medias in imageKeep list.
     * @param mediaTable, name of media table
     * @param imagesKeep, ids of the kept medias
     * @param featureID, id of the associated feature.
     * @return int, the number of the affected rows
     * @throws Exception
     */
    public int removeMedias (String mediaTable, ArrayList<String> imagesKeep, long featureID) throws Exception, DAOException {

        Collection<DBField> tabFields = getFieldsForMediaTable(mediaTable);
        String where = buildWhereClauseMediaIds(imagesKeep, tabFields);
        String[] whereArgs = new String[1];
        whereArgs[0] = ""+featureID;
        return this.database.getWritableDatabase().delete(mediaTable, where, whereArgs);
    }

    /**
     * Create a list of the ContentValues instances with pairs of the names and values for inserting into a media table.
     *
     * @param medias, the list of the medias in binary format.
     * @param tabFields The GeoPackage table fields to use for building the map.
     * @param featureID, the identified of the associated feature.
     * @param displayMetrics, are dimensions to build binary data from original file photo used to insert on media table.
     *                        Expected keys are: "displayWidth", "displayHeight", "thumbnailWidth" and "thumbnailHeight"
     * @return The list of ContentValues with key and value pairs.
     * @throws IOException
     */
    private ArrayList<ContentValues> buildInsertValues(ArrayList<String> medias, Collection<DBField> tabFields, long featureID, Map<String, Integer> displayMetrics) throws IOException, InvalidAppConfigException {

        // Construct values
        int len = medias.size();
        ArrayList<ContentValues> arrayListContentValues = new ArrayList<ContentValues>(len);

        String columnThumbnail = ResourceHelper.getStringResource(R.string.picture_thumbnail_media);
        String columnDisplayPhoto = ResourceHelper.getStringResource(R.string.picture_medium_size_media);
        String columnFullSizePhoto = ResourceHelper.getStringResource(R.string.picture_full_size_media);

        for (String mediaPath : medias) {
            ContentValues contentValues = new ContentValues(tabFields.size());

            byte[] pictureData = new byte[0];
            byte[] pictureDisplayData = new byte[0];
            byte[] pictureThumbnailData = new byte[0];

            if (mediaPath != null) {
                pictureData = MediaService.getBinaryData(mediaPath);

                pictureDisplayData = MediaService.getBinaryData(displayMetrics.get("displayWidth"), displayMetrics.get("displayHeight"), mediaPath);

                pictureThumbnailData = MediaService.getBinaryData(displayMetrics.get("thumbnailWidth"), displayMetrics.get("thumbnailHeight"), mediaPath);
            }

            // For each field defined in the table...
            for (DBField f : tabFields) {

                if (f.isPrimaryKey())
                    continue; // We can't insert or update the PK! shall be autoincrement

                // if integer is feature_id column
                if (f.getFieldType().toLowerCase().equals("integer")) {
                    contentValues.put(f.getFieldName(), featureID);
                } else if (f.getFieldType().toLowerCase().equals("blob")) {

                    if(f.getFieldName().equalsIgnoreCase(columnThumbnail)) {
                        contentValues.put(columnThumbnail, pictureThumbnailData);
                    }else if(f.getFieldName().equalsIgnoreCase(columnDisplayPhoto)) {
                        contentValues.put(columnDisplayPhoto, pictureDisplayData);
                    }else{
                        contentValues.put(columnFullSizePhoto, pictureData);
                    }

                } else if (f.getFieldType().toLowerCase().equals("text")) {
                    contentValues.put(f.getFieldName(), "image/jpeg");
                }
            }

            arrayListContentValues.add(contentValues);
        }

        return arrayListContentValues;
    }

    /**
     * Create a WHERE Clause to remove medias that in are mediaIds
     *
     * @param mediaIds, the list of the media ids.
     * @param tabFields The GeoPackage table fields to use for building the map.
     * @return The where clause to remove query.
     * @throws IOException
     */
    private String buildWhereClauseMediaIds(ArrayList<String> mediaIds, Collection<DBField> tabFields) throws Exception {

        String where;
        String ids = "";
        String fieldFeatureId = "";
        String fieldPrimaryKey = "";
        for (DBField f : tabFields) {
            if (f.isPrimaryKey()) {
                fieldPrimaryKey = f.getFieldName();
            }else if ("integer".equalsIgnoreCase(f.getFieldType())) {
                fieldFeatureId = f.getFieldName();
            }
        }
        if(fieldPrimaryKey.isEmpty() || fieldFeatureId.isEmpty()) {
            throw new Exception("Unknown media table.");
        }

        if(mediaIds!=null && !mediaIds.isEmpty()) {

            for (String id : mediaIds) {

                if (id != null && !id.isEmpty())
                    ids += (ids.isEmpty() ? "" : ",") + id;
            }
        }

        if(!ids.isEmpty()) where = fieldPrimaryKey + " NOT IN (" + ids + ") AND "+fieldFeatureId+"=?";
        else where = fieldFeatureId+"=?";

        return where;
    }

    /**
     * Create a WHERE Clause with the feature id
     *
     * @param tabFields The GeoPackage table fields to use for building the map.
     * @return The where clause with feature_id column.
     * @throws Exception
     */
    private String buildWhereClauseFeatureId(Collection<DBField> tabFields, long featureID) throws Exception {

        String where;
        String fieldFeatureId = "";
        for (DBField f : tabFields) {
            if (!f.isPrimaryKey() && f.getFieldType().toLowerCase().equals("integer")) {// feature_id column from media table
                fieldFeatureId = f.getFieldName();
                break;
            }
        }
        if(fieldFeatureId.isEmpty()) {
            throw new Exception("The Field Feature Id, not found on media table.");
        }

        where = fieldFeatureId + "=" + featureID;

        return where;
    }

    public boolean dropTable(String mediaTable) throws InvalidAppConfigException, DAOException {
        SQLiteDatabase db=null;
        try {
            db = database.getWritableDatabase();
            if (db != null) {
                db.beginTransaction();
                String sql = "DROP TABLE "+mediaTable;
                db.execSQL(sql);
                db.setTransactionSuccessful();
            }
        } catch (SQLiteException e) {
            e.printStackTrace();

            if(db!=null) db.close();

            throw new DAOException(ResourceHelper.getStringResource(R.string.media_table_delete_exception),e);
        }
        if(db!=null) {
            db.endTransaction();
            db.close();
            return true;
        }
        return false;
    }

    public boolean createTable(String layerName, String mediaTable, String layerPK) throws Exception, InvalidAppConfigException, DAOException {

        String mediaTableStmt = "CREATE TABLE IF NOT EXISTS '"+mediaTable+"' ("+
                ResourceHelper.getStringResource(R.string.pk_media)+" INTEGER PRIMARY KEY AUTOINCREMENT,"+
                ResourceHelper.getStringResource(R.string.feature_id_media)+" INTEGER NOT NULL,"+
                ResourceHelper.getStringResource(R.string.picture_full_size_media)+" BLOB,"+
                ResourceHelper.getStringResource(R.string.picture_medium_size_media)+" BLOB,"+
                ResourceHelper.getStringResource(R.string.picture_thumbnail_media)+" BLOB,"+
                ResourceHelper.getStringResource(R.string.picture_mime_type_media)+" TEXT";

        if(!layerPK.equals("rowid")) {
            mediaTableStmt += ", CONSTRAINT fk_feature_id FOREIGN KEY (feature_id) REFERENCES " + layerName + "(" + layerPK + ") ON DELETE CASCADE);";
        }else {
            mediaTableStmt += ");";
        }

        String updateTmLayerFormConfigStmt = "UPDATE "+ LayerFormDAO.TABLE_NAME+
                " SET "+ResourceHelper.getStringResource(R.string.media_layer_form)+
                "='"+mediaTable+"' WHERE "+
                ResourceHelper.getStringResource(R.string.identify_layer_form)+
                "='"+layerName+"';";

        SQLiteDatabase db=null;
        try {
            db = database.getWritableDatabase();
            if (db != null) {
                db.beginTransaction();
                db.execSQL(mediaTableStmt);
                db.execSQL(updateTmLayerFormConfigStmt);
                db.setTransactionSuccessful();
            }
        } catch (SQLiteException e) {
            e.printStackTrace();

            if(db!=null) db.close();

            throw new DAOException(ResourceHelper.getStringResource(R.string.media_table_create_exception),e);
        }
        if(db!=null) {
            db.endTransaction();
            db.close();
            return true;
        }
        return false;
    }
}
